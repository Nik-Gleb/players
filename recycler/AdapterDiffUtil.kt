package com.esn.platform.recycler

import android.annotation.SuppressLint
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.RecyclerView

/**
 * Создаёт новый экземпляр diff-callback.
 *
 * Данная реализация основана на моделях data-классах
 * с примитивными данными и корректной реализацией уникальности данных.
 *
 * @param Item тип данных моделей
 *
 * @return [DiffUtil.Callback] экземпляр
 */
@SuppressLint("DiffUtilEquals")
internal fun <Item : Any> createEqualsHashCodeDiffUtil() = object : DiffUtil.ItemCallback<Item>() {

    /**
     * Вызывается для определения, представляют ли два значения (старое и новое) один и тот же
     * элемент списка.
     *
     * Разработчику моделей крайне важно внимательно относиться к реализации этих моделей.
     * Такие объекты должны обязательно переопределять hashCode.
     *
     * Считается, что два элемента представляют одну и ту же сущность если:
     *  - их реализует один и тот же data-класс
     *  - их хэшкоды равны
     *
     * Таким образом hashCode должен представлять уникальный идентификатор сущности бизнес-уровня.
     * Или производную от него. При нарушении этого правила или нереализации custom hashCode метода,
     * становится невозможной доставка частичных обновлений определённым элементам.
     * Каждый раз система будет обнаруживать полностью новый список данных, уничтожать все старые
     * элементы и добавлять новые. Это не только сводит смысл diffUtil на нет, но так же может иметь
     * негативные последствия для UX: моргание всего списка, сброс скролл-позиции в начало.
     *
     * Рекомендуется:
     *  - в качестве хэшкода использовать серверные уникальные ключи сущностей
     *  - для всех остальных сценариев - вдумчиво выбирать одно из полей объекта однозначно
     *  идентифицирующего его
     *  - вычислять hash заведомо в конструкторе объекта, так как hashCode() может вызываться
     *  порядка сотен раз при поиске различий в больших списках
     *
     *  Например:
     *  В списке на 3-ей позиции представлен элемент "Марина Васильевна", после обновления списка на
     *  эту позицию приходит элемент "Марина Вяземская". В данном случае это может иметь два
     *  различных толкования:
     *   - "Васильевна" и "Вяземская" - это два разных человека
     *   - "Васильевна" и "Вяземская" - это один и тот же человек, сменивший фамилию
     *   В данном случае нам необходимо иметь уникальный ID этого человека для принятия правильного
     *   решения для UI. В первом сценарии произойдёт crossFade всей карточки пользователя.
     *   Во втором - существующая карточка отобразит анимацию смены фамилии.
     *
     * @param old старое значение
     * @param new новое значение
     *
     * @return true - если значения представляют один и тот же элемент.
     *              В этом случае следующим шагом будет вызов _[areContentsTheSame]_ для определения
     *              эквивалентности контента. В противном случае - false: произойдёт полная замена
     *              элемента на данной позиции. Для [RecyclerView] это будет означать удаление
     *              старого представления и добавление в данную позицию нового.
     */
    override fun areItemsTheSame(old: Item, new: Item) =
        old.javaClass === new.javaClass && old.hashCode() == new.hashCode()

    /**
     * Вызывается для проверки, что оба значения (старое и новое) имеют одни и те же данные.
     *
     * Разработчику моделей крайне важно внимательно относиться к реализации этих моделей.
     * Такие объекты не должны содержать поля с непримитивными типами данных, сложные объекты,
     * лямбды и интерфейсы.
     *
     * Элемент списка должен содержать только данные!
     * В противном случае - оказывается невозможным корректно трактовать изменения в элементе.
     *
     * При сравнивании двух объектов с лямдбами или интерфейсами появляется риск либо ложных
     * срабатываний, либо необнаружения изменений.
     *
     * Например: два элемента эквивалентны по примитивным свойствам, но также имеют поле
     * _OnClickListener_. Как правило такие обработчики реализуются в коде лямбдой или анонимным
     * классом, а значит, для equals это будет означать __РАЗНЫЕ__ объекты. В таком случае вью
     * получит ложное уведомление об изменении контента.
     * И наоборот: Если разработчик переопределил equals, так что  _OnClickListener_ игнорируется,
     * Это будет означать, что реальный новый слушатель так и не будет доставлен представлению и вью
     * будет продолжать отправлять события в старый нерелевантный колбэк.
     *
     * Всё это говорит о том, что разработчику необходимо проектировать вью-элементы списков
     * таким образом, чтобы они были самодостаточные.
     * Использовать весь необходимый для этого инструментарий фреймворка и лучшие практики DI.
     *
     * @param old старое значение
     * @param new новое значение
     *
     * @return true - если свойства элементов эквивалентны.
     *              В этом случае следующим шагом будет вызов _[getChangePayload]_ для определения
     *              полезной нагрузки и отправки её во вью. В противном случае - false: данная
     *              позиция остаётся нетронутой, представление не получит никаких нотификаций.
     */
    override fun areContentsTheSame(old: Item, new: Item): Boolean {
        return old == new
    }

    /**
     * Вычисление полезной нагрузки между двумя схожими элементами.
     *
     * Это значение будет отправлено во вью для обновления.
     * Текущая реализация подразумевает простой путь - отправлять новое значение целиком,
     * делегируя тем самым фактическое вычисление различий на ответственность самого представления.
     * В большинстве случаев представление уже содержит предыдущее состояние и лучше знает, как
     * отобразить трансформацию между значениями.
     *
     * Поддержка полезных нагрузок очень важна для плавной и корректной работы [RecyclerView].
     * Это позволяет поставлять изменения во вью более оптимизировано.
     *
     * Так, например, смена картинки во вью не должна анимироваться при "холодных" binding-ах по
     * факту прокрутки списка, но может быть вполне анимирована при горячей замене, когда элемент не
     * покидал видимую область, а фото профиля, скажем, было изменено пользователем.
     *
     * @param old старое значение
     * @param new новое значение
     *
     * @return полезная нагрузка
     */
    override fun getChangePayload(old: Item, new: Item) = new
}
